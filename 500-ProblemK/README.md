# K. Non-decreasing Sequence of Longest Increasing Subsequence

実行時間制限: 2 sec / メモリ制限: 256 MB  

## 問題文

あなたは以下のような擬似コードによって表されるソートアルゴリズムを考えました.  
  
```
for i=n-1 down to 0 :
	max = 0
	for j=1 to i :
		if a[max] < a[j] :
			max = j;
		end if
	end for
	
	for j=max to i-1 :
		swap(a[j],a[j+1])
	end for
end for

```

\\(
[9, 4, 5, 6, 2, 7, 3, 1, 8]
\\)
という数列をこのアルゴリズムでソートしてみると以下のように動作します.  

---

\\(
[9, 4, 5, 6, 2, 7, 3, 1, 8]
\\) 初期状態  
\\(
[4, 5, 6, 2, 7, 3, 1, 8, 9]
\\) 一番大きな\\(9\\)が列の末尾に移動される(\\(9\\)をソート済みとする).  
\\(
[4, 5, 6, 2, 7, 3, 1, 8, 9]
\\) ソート済みでない数で一番大きな\\(8\\)がソート済みでない部分列の末尾に移動される(\\(8\\)をソート済みとする).  
\\(
[4, 5, 6, 2, 3, 1, 7, 8, 9]
\\) 以下同様.  
\\(
[4, 5, 2, 3, 1, 6, 7, 8, 9] \\
[4, 2, 3, 1, 5, 6, 7, 8, 9] \\
[2, 3, 1, 4, 5, 6, 7, 8, 9] \\
[2, 1, 3, 4, 5, 6, 7, 8, 9] \\
[1, 2, 3, 4, 5, 6, 7, 8, 9] \\
\\)
\\(
[1, 2, 3, 4, 5, 6, 7, 8, 9] \\
\\) 状態は変わらないがループは回る.

---

ソート過程の各ステップがどれだけ最終的なソート結果に近いかを知るための方針として, ステップ毎に最長増加部分列の長さを求めてみることにしました.
ある数列\\(A=a_0,a_1,\cdots,a_{N-1}\\)において, \\(0 \leq i_0 \lt i_1 \lt \cdots \lt i_K < N\\)かつ\\(a_{i_0} \lt a_{i_1} \lt \cdots \lt a_{i_K}\\)を満たす部分列は増加部分列と呼ばれ, 増加部分列の中で最も\\(K\\)が大きいものは最長増加部分列(以下\\(LIS\\))と呼ばれます.  
  
数列の要素数\\(N\\), 数列\\(A\\)が与えられるので, 初期状態の\\(LIS\\)の長さとネストの浅いループが回り終わる度にその状態での\\(LIS\\)の長さを求めてください.  

## 入力

入力は以下の形式で標準入力から与えられます.  

\\(
N \\
a_0 \\
\vdots \\
a_i \\
\vdots \\
a_{N-1} \\
\\)

- \\(1\\)行目に\\(N\\)が空白区切りで与えられます.
- \\(2\\)行目からの\\(N\\)行に\\(A\\)の\\(i\\)番目の要素\\(a_i\\)が与えられます.

### 制約

\\(
1 \leq N \leq 10^5 \\
1 \leq a_i \leq 10^9 \\
\\)
\\(i \neq j\\)のとき, \\(a_i \neq a_j\\)

## 出力

標準出力に, 初期状態の\\(LIS\\)の長さを1行で出力し, 続く\\(N\\)行にはループが回り終わる度にその状態での\\(LIS\\)の長さを\\(1\\)行ずつ出力してください.  
出力の末尾には改行を入れてください.  


---

### 入力例1

```
9
9 4 5 6 2 7 3 1 8

```

### 出力例1

```
5
6
6
6
6
7
8
8
9
9

```

---

### 入力例2

```
9
7 2 6 3 4 5 8 1 9

```

### 出力例2

```
6
6
6
7
8
8
8
8
9
9

```